1 outline
(1) array
(2) C-style string, string-class, getline(), get(), mixing string and numeric input
(3) structure, union
(4) enumerations
(5) pointers
(6) dynamic memory, new and delete, dynamic array, structure

far-reaching, bastion

2 array
typeName arrayName[arraySize];
arraySize must be an integer constant
subscript, index
the compiler does not check to see if you use a valid subscript

the element takes on whatever value previously resided at that location in memory.

if partially initialize an array, the compiler sets the remaining elements to zero
int counts[10] = {};  // all elements set to zero

3 strings
A string is a series of characters stored in consecutive bytes of memory.
char dog[8] = {'b', 'e', 'a', 'u', 'x', ' ', 'i', 'i'};  // not a string
char cat[8] = {'f', 'e', 'a', 's', 's', 'p', 'i', '\0'};  // a string, '\0' null character
cout << dog; //cout 8 letters and then keeps marching through memory byte by byre, until it reaches '\0'
cout << cat; // display 7 characters

char bird[] = "bubbles"; //string literal to initialize array, always include the '\0'
char boss[8] = "Bozo"; // remaining elements set to '\0'

 ***  's' is a shorthand notation for the code for a character, in ASCII system, 'S' is another way of writing 83
 ***  "s" represents the string consisting of 2 characters, the 's' and '\0'
 ***  concatenate string literals
 cout << "l would give" " you an apple.\n";
 cout << "l would give you an apple.\n";
 cout << "l would give"
 " you an apple.\n";
 
 strlen(), sizeof()
 minimum array size is strlen(arr) + 1
 
 conceal, surface, remove the veils and shows that string input can be tricky
 
 The cin use whitespace, spaces, tabs, and newlines, to delineate a string 
 char name[100] = {};
 cin >> name;
 cout << name;
 
 The getline() function reads a whole line, using the newline character transmitted by the CARRIER RETURN
 char name[100] = {};
 cin.getline(name, arrSize); // cin.getline() takes 2 arguments, arrSize is a limit of numbers of characters to read
 cout << name;
 *** the cin.getline() stops reading input when it reaches limit or when reads a newline character
 read newline character and replace it with '\0'
 
 cin.get() leaves newline character in the input queue, the next cin.get() can not past that newline character
 	char name[100] = {};
	char age[10] = {};
	cin.get(name, 20).get();
	cin.get(age, 8);
	cout << name;
	cout << age;
 
 cin.getline(name, 20).getline(age, 8);
 
 cin.get() how can you tell if read the whole line rather than stopped because the array was filled, look at the next
 
 *** cin << name; leaves the newline generated by the Enter key in the input queue.
 (cin >> name).get();
 
 #include <string>
 #include <cstring>
 strcpy(char1,char2);
 strcat(char1,char2);
 str1.size();
 sizeof(char1);
 strlen(char1); // *** counting bytes until it reaches '\0'
 
 str3 = str1 + str2;
 
 string age;
 getline(cin, age); // tells where to find input
 cout << age;
 
 3 structure 
 *** The structure type is a stepping stone to that bulwark of C++ OOP.
 struct inflat
 {
 	char name[20];
	float volume;
	double price;
 };
 
 inflat goose = { "hello world", 1.2, 29.2}; 
 inflat guest = 
 {
 	"hello world",
	1.8,
	29.9
 };
 
 cout << goose.price +guest.price << endl;
 external declaration, local declaration
 
 function arguments, return value, assignment operator
 
 defer
 
 *** You can combine the definition of a structure form with the creation of structure variables.
 *** However,keeping them separated makes a program easier to read and follow.
 struct inflat
 {
 	char name[20];
	float volume;
	double price;
 }goose = { "hello world", 1.2, 29.2},
 guest = {"hello world", 1.8, 29.9};
 
 cout << goose.price +guest.price << endl;
 
 *** You can not subsequently create other variables of the same type.
 struct 
 {
 	char name[20];
	float volume;
	double price;
 }goose = { "hello world", 1.2, 29.2},
 guest = {"hello world", 1.8, 29.9};
 
 *** Unlike C structures, C++ structures can have member functions in addition to member variables.
 
 Union
 The size of union is the size of its largest member.
 One use for a union is to save space when a data item can use two or more formats but never simultaneously.
 Because the union is anonymous, id_num and id_char are treated as two members of prize that share the same address.
 
 gigabyte, terabyte, premium
 
 4 enumeration
 The syntax for enum resembles structure syntax.
 enum spectrum {red, orange,yellow, green, blue, violet, indigo, ultraviolet}; // makes spectrum the name of a new type
 spectrum band = red; // By default, enumerators are assigned integer values starting with 0
 cout << band<< endl;
 
 5 pointers
 (1) pointers and numbers
 *** if use a numeric value as an address, you should use a type cast to convert the number to appropriate address type
 int * pt;
 pt = (int *) 0xB800000
 cout << *pt
 
 (2) allocating memory with new
 when you allocate unnamed memory during runtime to hold values, pointers become the only access to that memory.
 int * pn = new int; // once to specify the kind of memory requested and once to declare a suitable pointer.
 cout << pn;
 
 *** ordinary variable have their values stored in a memory region called the stack
 whereas the memory allocated by new is in a region called the heap or free store
 
 (3) freeing memory with delete
 int * ps  = new int;
 delete ps; // This removes the memory to which ps points
 you can reuse ps to point to another new allocation.
 you cannot use delete to free memory created by declaring ordinary variables
 
 (4) using new to create dynamic arrays
 *** If you create an array by declaring it, the space is allocated when the program is compiled.
 *** Allocating the array during compile time is called static binding
 *** dynamic binding, array is created while the program is running
 int * psome = new int [10]; // the new operator returns the address of the first elementof the block
 delete [] psome; // the [] tells the program that it should free the whole array, not just the first element 
 ***** the program keeps track of the memory, but that information isn't available.
 *** Use the pointer as if it were an array name, psome[0], *psome 
 *** C/C++ handle arrays internally by using pointers
??? difference: p3 = p3+1 // okay for pointers, wrong for array names
sizeof(pointer), sizeof(arrName)

 int psome[3] = {};
 cout << &psome << endl << &psome + 1 << endl; // display address of whole array
 cout << psome << endl << psome + 1; // display &tell[0]
 
 (5) pointers and strings
  special relationship between arrays and pointers extends to C-style strings.
  char flower[10] = "rose";
  if you give the address of a character, it prints everything from that character to the first '\0'
  cout << "a flower"; "a flower" is also an address
  cout << &"hello";
  Normally, if you give cout a pointer, it prints an address. 
  But if the pointer is type char *, cout display the pointed-to string.
  If you want to see the address of the string, you have to type cast the pointer to another pointer type, such as int *
  
  	char animal[20] = "beauty";

	char * string1 = { };
	cout << ( int * ) string1 << endl;

	string1 = animal;
	cout << (int *)string1;
 output :
 00000000
 0079F8B4
	
  Tipically, a compiler sets aside an area in memory to hold all the quoted strings used in the program source code,
  associating each stored string with its address
 
  const char * bird = "wren";
  String literals are constants, which is why the code uses the const keyword in the declaration.
  Using const in this fashion means you use bird to access the string but not to change it.
 
 (6) using new to create dynamic structures
 
 struct inflat
 {
	float volume;
	double price;
 };
 inflat goose = {1.2, 29.2};
 inflat * guest = &goose;
 
 cout << guest->price << endl;
 cout << goose.price << endl;
 cout << (*guest).price;
  
  . dot membership operator
  -> arrow membership operator
  
  contiguous, memory leaks 
  
(7) vector
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main() {
	int n;
	cin >> n;
	vector<double> name(n);
	name[1] = 5;
	cout << name[1] << endl << name[0];
	return 0;
}
  
 name is an object of type vector<double> and

(8) array tempalte class
#include <iostream>
#include <array>
using namespace std;

int main() {
	array<double, 4> name;
	name[1] = 5;
	cout << name[1] << endl << name[0];
	return 0;
}
You can assign an array object to another array object
 
 
 
 
 
