1 outline
(1) naming variables
(2) integers types
(3) climits file
(4) numeric literals (constants)
(5) const qualifier
(6) built-in floating-point types
(7) cfloat file
(8) numeric literals of various floating-point types
(9) C++'s arithmetic operators
(10) automatic type conversions
(11) forced type conversions

*** The essence of OOP is desiging and extending your own data types.
fundamental types (integers and floating-point numbers) and compound types (arrays,strings, pointers and structures)

2 simple variables
three fundamental properties: where, value, type
underscore _ , __fools reserved, strident
nMyWeight a prefix that describes the variable's type
presage, positive and negative value
The funfamental unit of computer memory is the bit.
Think of a bit as an electronic switch that you can set to either off or on.
kilobyte, megabyte
short is short for short int
sizeof operator
symbolic constants the preprocessor way
#define INT_MAX 32767  C relic
look through the program for instance of INT_MAX and replace each occurrence with 32767.
const keyword
initialization combines assignment with declaration
decimal, hex, octal
cout << oct;
cout << 45;
suffix 123L
In practice, many systems support fewer than 128 kinds of characters, so a single byte can represent the whole range.
cin and cout are guided by the type of variable.
*** C++ uses single quotation marks for a character and double quotation marks for a string.
cout << 'q'; cout.put('q');
escape sequence 转义字符 '\n'
*** C++ interprets nonzero values as true and zeros values as false.
bool is_ready = true;

3 floating-point type
conspiracy
moving decimal point is the origin of the term "floating-point."
By default, floating-point type constants are type double.
scaling factor, operands, modulus 19 % 5 = 4

*** order of operation: operator precedence and associativity

4 type conversions
profusion
(1) conversion on initialization and assignment
the value is converted to the type of the receiving variable.
loss of precision, out of range
C++ uses truncation (discarding the fractional part) and not rounding (finding the closest integer value) when converting floating-point value to integer types.
*** short fowl = chickens + ducks;
a  If either operand is type  long double, the other operand is converted to  long double. 
b  Otherwise,if either operand is  double, the other operand is converted to  double. 
c  Otherwise,if either operand is  float, the other operand is converted to  float.
d  Otherwise,the operands are integer types and the integral promotions are made. 
e  In that case, if both operands are signed or if both are unsigned, and one is of lower rank than the other, it is converted to the higher rank. 
f  Otherwise,one operand is signed and one is unsigned. If the unsigned operand is of higher rank than the signed operand, the latter is converted to the type of the unsigned operand. 
g  Otherwise,if the signed type can represent all values of the unsigned type, the unsigned operand is converted to the type of the signed type. 
h  Otherwise,both operands are converted to the unsigned version of the signed type.

(2) conversions in passing arguments
type casts 类型强制转换
C++ empowers you to force type conversions explicitly via type cast mechanism.
(long) thorn // C style
long (thorn) // pure C++
adding 19.99 to 11.99 yields 31.98.
2 reasons to use type casting.
first, you might have values that are stored as type double but used to calculate a type int value. 
second, the capability to compel data in one form to meet a different expectation.

5 auto declarations
C++ 11 allows compiler to deduce a type from the type from the type of an initialization value.
astray

6 Answer
The distinction between  char grade = 65 and char grade = 'A':
 char grade = 65 only on systems using ASCII code.










